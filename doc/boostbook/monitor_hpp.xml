<header name="poet/monitor.hpp">
	<namespace name="poet">
		<class name="monitor">
			<template>
				<template-type-parameter name="T"/>
				<template-type-parameter name="Mutex">
					<default>boost::mutex</default>
				</template-type-parameter>
			</template>
			<purpose>A wrapper which provides insures locked access to an object.</purpose>
			<description>
				<para>
					<code>monitor</code> allows for the easy creation of simple monitor objects.
					A <code>monitor</code> provides automatically locked access to its contained object's members
					through its scoped lock classes, which can be used like pointers.
					It stores its contained object by value, as an alternative to the pointer-like
					interface of <classname>monitor_ptr</classname>.
					Copies of a <code>monitor</code> object are deep copies, which do not share
					the same mutex/condition.
				</para>
				<para>
					Although any copy-constructible object may be contained in a <code>monitor</code>,
					special support is provided
					for classes derived from <classname>monitor_base</classname>.  This allows classes derived from
					<classname>monitor_base</classname> to wait on conditions inside member function calls,
					releasing the <code>monitor</code>'s mutex until the condition is satisfied.
				</para>
				<para>
					The <code>Mutex</code> template type must be a model of the Mutex concept as
					described in the Boost Thread library.  If <code>Mutex</code> is additionally
					a model of the TryMutex or TimedMutex concept then the nested class <classname>monitor::scoped_try_lock</classname>
					is available for "try locking".  If <code>Mutex</code> is a model of the TimedMutex
					concept then the nested class <classname>monitor::scoped_timed_lock</classname>
					is also available for "timed locking".  Libpoet determines if the <code>Mutex</code>
					template type parameter supports try or timed locking by testing the value of
					mutex_properties&lt;Mutex&gt;::model.
				</para>
				<itemizedlist>
					<title>Example Code</title>
					<listitem>
						<para>
							<link linkend="poet.example.monitor_demo.cpp">monitor_demo.cpp</link>
						</para>
					</listitem>
				</itemizedlist>
				<itemizedlist>
					<title>See also</title>
					<listitem>
						<para>
							<classname>monitor_ptr</classname>: a pointer-like alternative to the <code>monitor</code> class.
						</para>
					</listitem>
				</itemizedlist>
			</description>
			<access name="public">
				<typedef name="value_type">
					<type>T</type>
				</typedef>
				<typedef name="mutex_type">
					<type>Mutex</type>
				</typedef>
				<class name="scoped_lock">
					<inherit access="public">
						<type><classname>detail::monitor_scoped_lock</classname>&lt;T, Mutex&gt;</type>
					</inherit>
					<purpose>Scoped lock with member access</purpose>
					<description>
						<para>
							<code>monitor::scoped_lock</code> models the ScopedLock concept described by the
							Boost Thread libarary, with its associated mutex type being <classname>monitor</classname>.
							In addition, <code>scoped_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object owned
							by a <classname>monitor</classname>.
						</para>
					</description>
					<access name="public">
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>monitor</code>, and calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>.
								</para>
							</description>
							<postconditions>
								<para><code>locked() == true</code></para>
							</postconditions>
						</constructor>
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<class name="scoped_try_lock">
					<inherit access="public">
						<type><classname>detail::monitor_scoped_try_lock</classname>&lt;T, Mutex&gt;</type>
					</inherit>
					<purpose>Scoped try lock with member access</purpose>
					<description>
						<para>
							<code>monitor::scoped_try_lock</code> models the ScopedTryLock concept described by the
							Boost Thread libarary, with its associated mutex type being <classname>monitor</classname>.
							In addition, <code>scoped_try_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object contained
							in a <classname>monitor</classname>.
						</para>
					</description>
					<access name="public">
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>,
									and calls <methodname alt="detail::monitor_scoped_try_lock::try_lock">try_lock</methodname>().
								</para>
							</description>
						</constructor>
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<class name="scoped_timed_lock">
					<inherit access="public">
						<type><classname>detail::monitor_scoped_timed_lock</classname>&lt;T, Mutex&gt;</type>
					</inherit>
					<purpose>Scoped timed lock with member access</purpose>
					<description>
						<para>
							<code>monitor::scoped_timed_lock</code> models the ScopedTimedLock concept described by the
							Boost Thread libarary, with its associated mutex type being <classname>monitor</classname>.
							In addition, <code>scoped_timed_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object contained
							in a <classname>monitor</classname>.
						</para>
					</description>
					<access name="public">
						<constructor>
							<template>
								<template-type-parameter name="Timeout"/>
							</template>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="timeout">
								<paramtype>const Timeout &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>,
									and calls <code><methodname alt="detail::monitor_scoped_timed_lock::timed_lock">timed_lock</methodname>(timeout)</code>.
								</para>
							</description>
						</constructor>
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<method-group name="public member functions">
					<method name="operator=">
						<template>
							<template-type-parameter name="U"/>
							<template-type-parameter name="M"/>
						</template>
						<type>monitor&lt;T, Mutex&gt; &amp;</type>
						<parameter name="rhs">
							<paramtype>const monitor&lt;U, M&gt; &amp;</paramtype>
						</parameter>
						<description>
							<para>Copies the value of type <code>T</code> from <code>rhs</code>
								into <code>*this</code>.
							</para>
							<para>
								The mutex of the <code>rhs</code> parameter is locked while its contained value
								is copied out of it.  Similarly, the mutex of <code>*this</code> is locked
								while its new value is copied into it.  However, care is taken
								not to lock both <code>*this</code> and <code>rhs</code>
								simultaneously, to avoid violating
								or establishing a locking order between the two monitors (which might result in deadlock).
							</para>
							<para>
								Copies of a <code>monitor</code> object are deep copies, which do not share
								the same mutex or condition.
							</para>
						</description>
					</method>
					<method name="swap">
						<template>
							<template-type-parameter name="M"/>
						</template>
						<type>void</type>
						<parameter name="other">
							<paramtype>monitor&lt;T, M&gt; &amp;</paramtype>
						</parameter>
						<description>
							<para>
								Swaps the values of <code>*this</code> and <code>other</code>.  This
								function is provided to implement
								<functionname>swap</functionname> for this class, which may
								enhance efficiency with generic algorithms.
							</para>
							<para>
								Care is taken
								not to lock both <code>monitor</code> objects simultaneously to avoid violating
								or establishing a locking order between the two monitors (which might result in deadlock).
								The swap operation performs the following steps:
							</para>
							<itemizedlist>
								<listitem>
									<para>
										Copy constructs a temporary value of type T from the value in <code>other</code>, while
										<code>other</code> is locked.
									</para>
								</listitem>
								<listitem>
									<para>
										Swaps the temporary value with the value of <code>*this</code>, while
										<code>*this</code> is locked.
									</para>
								</listitem>
								<listitem>
									<para>
										Swaps the temporary value with the value of <code>other</code>, while
										<code>other</code> is locked.
									</para>
								</listitem>
							</itemizedlist>
							<para>
								Therefore, it is possible another thread could lock <code>other</code> and
								perform some operation on it between the point where its value is copied
								out, and the point where the value from <code>*this</code> is swapped back into
								<code>other</code>.
							</para>
						</description>
					</method>
				</method-group>
				<constructor>
					<description>
						<para>Creates a <code>monitor</code> with a default-constructed value.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="value">
						<paramtype>const T &amp;</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>monitor</code> which contains a value copy-constructed from
							the constructor's argument.
						</para>
					</description>
				</constructor>
				<constructor>
					<template>
						<template-type-parameter name="U"/>
						<template-type-parameter name="M"/>
					</template>
					<parameter name="other">
						<paramtype><classname>monitor</classname>&lt;U, M&gt; &amp;</paramtype>
					</parameter>
					<description>
						<para>
							Creates a <code>monitor</code> whose contained value is copy-constructed from the
							value contained in the <code>other</code> parameter.  <code>other</code> is
							locked while its value is copied out.
						</para>
					</description>
				</constructor>
				<constructor>
					<template>
						<template-type-parameter name="U1"/>
						<template-type-parameter name="U2"/>
						<template-type-parameter name="..."/>
						<template-type-parameter name="UN"/>
					</template>
					<parameter name="arg1"><paramtype>U1</paramtype></parameter>
					<parameter name="arg2"><paramtype>U2</paramtype></parameter>
					<parameter><paramtype>...</paramtype></parameter>
					<parameter name="argN"><paramtype>UN</paramtype></parameter>
					<description>
						<para>
							Creates a <code>monitor</code> by forwarding the constructor's arguments
							to the constructor for the contained value.  If you need to pass
							a reference to the contained value's constructor, you should wrap it
							in a <classname>boost::reference_wrapper</classname> to prevent it
							from being automatically converted to a value.
						</para>
						<para>
							If you wish to change the maximum number of arguments this family of constructors can take
							from its default value of 10, you may define the macro <code>POET_MONITOR_MAX_CONSTRUCTOR_ARGS</code>
							to your desired value prior to including monitor.hpp.
						</para>
					</description>
				</constructor>
				<destructor specifiers="virtual"/>
			</access>
		</class>
		<function name="swap">
			<template>
				<template-type-parameter name="T"/>
				<template-type-parameter name="Mutex"/>
			</template>
			<parameter name="monitor0"><paramtype>monitor&lt;T, Mutex&gt; &amp;</paramtype></parameter>
			<parameter name="monitor1"><paramtype>monitor&lt;T, Mutex&gt; &amp;</paramtype></parameter>
			<type>void</type>
		</function>
	</namespace>
</header>
