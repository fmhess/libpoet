<header name="poet/monitor.hpp">
	<namespace name="poet">
		<class name="monitor">
			<template>
				<template-type-parameter name="T"/>
				<template-type-parameter name="Mutex">
					<default>boost::mutex</default>
				</template-type-parameter>
			</template>
			<purpose>A wrapper which provides insures locked access to an object.</purpose>
			<description>
				<para>
					<code>monitor</code> allows for the easy creation of monitor objects.
					A <code>monitor</code> provides automatically locked access to its contained object's members
					through its scoped lock classes, which can be used like pointers.
					It is similar to a <classname>monitor_ptr</classname>, except it behaves like a value
					instead of a smart pointer when copied.
					Copies of a <code>monitor</code> object are deep copies with independent values, and
					do not share the same mutex/condition.
				</para>
				<para>
					Although any object may be wrapped in a <code>monitor</code>,
					special support is provided
					for classes derived from <classname>monitor_base</classname>.  This allows classes derived from
					<classname>monitor_base</classname> to wait on conditions inside member function calls,
					releasing the <code>monitor</code>'s mutex until the condition is satisfied.
				</para>
				<para>
					The <code>Mutex</code> template type must be a model of the Mutex concept as
					described in the Boost Thread library.  If <code>Mutex</code> is additionally
					a model of the TryMutex or TimedMutex concept then the nested class <classname>monitor::scoped_try_lock</classname>
					is available for "try locking".  If <code>Mutex</code> is a model of the TimedMutex
					concept then the nested class <classname>monitor::scoped_timed_lock</classname>
					is also available for "timed locking".
				</para>
				<para>
					It is possible to obtain <classname>monitor_ptr</classname>s from a <code>monitor</code> which shares
					ownership/mutex/condition and points at
					the value wrapped in a <code>monitor</code> object, via the <methodname>get_monitor_ptr</methodname>
					method.  The value wrapped in a <code>monitor</code> object will not be destructed until
					the last such <code>monitor_ptr</code> is destroyed, along with the <code>monitor</code>
					object wrapping it, and any scoped locks which reference it.
				</para>
				<itemizedlist>
					<title>Example Code</title>
					<listitem>
						<para>
							<link linkend="poet.example.monitor_demo.cpp">monitor_demo.cpp</link>
						</para>
					</listitem>
				</itemizedlist>
				<itemizedlist>
					<title>See also</title>
					<listitem>
						<para>
							<classname>monitor_ptr</classname>: a pointer-like alternative to the <code>monitor</code> class.
						</para>
					</listitem>
				</itemizedlist>
			</description>
			<access name="public">
				<typedef name="element_type">
					<type>T</type>
				</typedef>
				<typedef name="mutex_type">
					<type>Mutex</type>
				</typedef>
				<class name="scoped_lock">
					<inherit access="public">
						<type><classname>detail::monitor_scoped_lock</classname>&lt;T, Mutex&gt;</type>
					</inherit>
					<purpose>Scoped lock with member access</purpose>
					<description>
						<para>
							<code>monitor::scoped_lock</code> models the ScopedLock concept described by the
							Boost Thread libarary, with its associated mutex type being <classname>monitor</classname>.
							In addition, <code>scoped_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object owned
							by a <classname>monitor</classname>.
						</para>
					</description>
					<access name="public">
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>monitor</code>, and calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>.
								</para>
							</description>
							<postconditions>
								<para><code>locked() == true</code></para>
							</postconditions>
						</constructor>
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<class name="scoped_try_lock">
					<inherit access="public">
						<type><classname>detail::monitor_scoped_try_lock</classname>&lt;T, Mutex&gt;</type>
					</inherit>
					<purpose>Scoped try lock with member access</purpose>
					<description>
						<para>
							<code>monitor::scoped_try_lock</code> models the ScopedTryLock concept described by the
							Boost Thread libarary, with its associated mutex type being <classname>monitor</classname>.
							In addition, <code>scoped_try_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object contained
							in a <classname>monitor</classname>.
						</para>
					</description>
					<access name="public">
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>,
									and calls <methodname alt="detail::monitor_scoped_try_lock::try_lock">try_lock</methodname>().
								</para>
							</description>
						</constructor>
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<class name="scoped_timed_lock">
					<inherit access="public">
						<type><classname>detail::monitor_scoped_timed_lock</classname>&lt;T, Mutex&gt;</type>
					</inherit>
					<purpose>Scoped timed lock with member access</purpose>
					<description>
						<para>
							<code>monitor::scoped_timed_lock</code> models the ScopedTimedLock concept described by the
							Boost Thread libarary, with its associated mutex type being <classname>monitor</classname>.
							In addition, <code>scoped_timed_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object contained
							in a <classname>monitor</classname>.
						</para>
					</description>
					<access name="public">
						<constructor>
							<template>
								<template-type-parameter name="Timeout"/>
							</template>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="timeout">
								<paramtype>const Timeout &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>,
									and calls <code><methodname alt="detail::monitor_scoped_timed_lock::timed_lock">timed_lock</methodname>(timeout)</code>.
								</para>
							</description>
						</constructor>
						<constructor>
							<parameter name="mon">
								<paramtype><classname>monitor</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object contained in a <code>monitor</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname alt="detail::monitor_scoped_lock::lock">lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<method-group name="public member functions">
					<overloaded-method name="get_monitor_ptr">
						<signature>
							<type>const <classname>monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</type>
						</signature>
						<signature cv="const">
							<type><classname>monitor_ptr</classname>&lt;const T, Mutex&gt;</type>
						</signature>
						<description>
							<para>
								The <code>get_monitor_ptr</code> method can be used to obtain a <classname>monitor_ptr</classname> which shares
								ownership/mutex/condition with <code>*this</code>.
							</para>
						</description>
					</overloaded-method>
					<method name="operator=">
						<template>
							<template-type-parameter name="U"/>
							<template-type-parameter name="M"/>
						</template>
						<type>monitor&lt;T, Mutex&gt; &amp;</type>
						<parameter name="rhs">
							<paramtype>const monitor&lt;U, M&gt; &amp;</paramtype>
						</parameter>
						<description>
							<para>Copies the value of type <code>T</code> from <code>rhs</code>
								into <code>*this</code>.
							</para>
							<para>
								The mutex of the <code>rhs</code> parameter is locked while its contained value
								is copied out of it.  Similarly, the mutex of <code>*this</code> is locked
								while its new value is copied into it.  However, care is taken
								not to lock both <code>*this</code> and <code>rhs</code>
								simultaneously, to avoid violating
								or establishing a locking order between the two monitors (which might result in deadlock).
							</para>
							<para>
								Copies of a <code>monitor</code> object are deep copies, which do not share
								the same mutex or condition.
							</para>
						</description>
					</method>
					<overloaded-method name="operator->">
						<signature>
							<type>const <classname>monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</type>
						</signature>
						<signature cv="const">
							<type><classname>monitor_ptr</classname>&lt;const T, Mutex&gt;</type>
						</signature>
						<description>
							<para>
								Provides automatically locked access to members of the wrapped value.
							</para>
							<para>
								If more flexibility is desired, the <classname>monitor::scoped_lock</classname>,
								<classname>monitor::scoped_try_lock</classname>, and
								<classname>monitor::scoped_timed_lock</classname>
								classes provides alternatives to <code>monitor::operator-&gt;</code>.
							</para>
						</description>
					</overloaded-method>
					<method name="swap">
						<template>
							<template-type-parameter name="M"/>
						</template>
						<type>void</type>
						<parameter name="other">
							<paramtype>monitor&lt;T, M&gt; &amp;</paramtype>
						</parameter>
						<description>
							<para>
								Swaps the wrapped values of <code>*this</code> and <code>other</code>.
								Only the wrapped values of the two monitors are swapped, not their mutexes
								or condition variables.
							</para>
							<para>
								The mutexes of both monitors are locked before
								their values are swapped.  The mutexes are locked by trying each of the
								two possible locking orders until both mutexes are successfully locked.
								This avoids any possibility of deadlock due to locking order violation,
								but may produce false positives when using debugging tools such as
								<classname>acyclic_mutex</classname>.
							</para>
						</description>
					</method>
				</method-group>
				<constructor>
					<description>
						<para>Creates a <code>monitor</code> with a default-constructed value.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="value">
						<paramtype>const T &amp;</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>monitor</code> which contains a value copy-constructed from
							the constructor's argument.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="other">
						<paramtype>const <classname>monitor</classname> &amp;</paramtype>
					</parameter>
					<description>
						<para>
							The copy constructor creates a <code>monitor</code> whose contained value is
							copy-constructed from the
							value contained in the <code>other</code> parameter.  <code>other</code> is
							locked while its value is copied out.
						</para>
					</description>
				</constructor>
				<constructor>
					<template>
						<template-type-parameter name="U"/>
						<template-type-parameter name="M"/>
					</template>
					<parameter name="other">
						<paramtype>const <classname>monitor</classname>&lt;U, M&gt; &amp;</paramtype>
					</parameter>
					<description>
						<para>
							Creates a <code>monitor</code> whose contained value is copy-constructed from the
							value contained in the <code>other</code> parameter.  The type <code>U</code> must
							be implicitly convertible to type <code>T</code>.  <code>other</code> is
							locked while its value is copied out.
						</para>
					</description>
				</constructor>
				<constructor>
					<template>
						<template-type-parameter name="U1"/>
						<template-type-parameter name="U2"/>
						<template-type-parameter name="..."/>
						<template-type-parameter name="UN"/>
					</template>
					<parameter name="arg1"><paramtype>U1</paramtype></parameter>
					<parameter name="arg2"><paramtype>U2</paramtype></parameter>
					<parameter><paramtype>...</paramtype></parameter>
					<parameter name="argN"><paramtype>UN</paramtype></parameter>
					<description>
						<para>
							Creates a <code>monitor</code> by forwarding the constructor's arguments
							to the constructor for the contained value.  If you need to pass
							a reference to the contained value's constructor, you should wrap it
							in a <classname>boost::reference_wrapper</classname> to prevent it
							from being automatically converted to a value.
						</para>
						<para>
							If you wish to change the maximum number of arguments this family of constructors can take
							from its default value of 10, you may define the macro <code>POET_MONITOR_MAX_CONSTRUCTOR_ARGS</code>
							to your desired value prior to including monitor.hpp.
						</para>
					</description>
				</constructor>
				<destructor specifiers="virtual"/>
			</access>
			<free-function-group name="free function: swap">
				<function name="swap">
					<template>
						<template-type-parameter name="T"/>
						<template-type-parameter name="Mutex"/>
					</template>
					<parameter name="monitor0"><paramtype>monitor&lt;T, Mutex&gt; &amp;</paramtype></parameter>
					<parameter name="monitor1"><paramtype>monitor&lt;T, Mutex&gt; &amp;</paramtype></parameter>
					<type>void</type>
					<description>
						<para>
							Swaps the values of <code>monitor0</code> and <code>monitor1</code>.  This
							function is provided to
							enhance efficiency with generic algorithms.
						</para>
					</description>
					<effects>
						<para><code>monitor0.swap(monitor1);</code></para>
					</effects>
				</function>
			</free-function-group>
		</class>
	</namespace>
</header>
