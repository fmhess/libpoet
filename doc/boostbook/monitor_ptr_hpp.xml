<header name="poet/monitor_ptr.hpp">
	<namespace name="poet">
		<class name="monitor_ptr">
			<template>
				<template-type-parameter name="T"/>
				<template-type-parameter name="Mutex">
					<default>boost::mutex</default>
				</template-type-parameter>
			</template>
			<purpose>A smart pointer which provides automatically locked access to an object.</purpose>
			<description>
				<para>
					<code>monitor_ptr</code> allows for the easy creation of simple monitor objects.  A
					<code>monitor_ptr</code> provides automatically locked access to an object's members
					when they are accessed through the overloaded <methodname>operator-&gt;</methodname>,
					or alternatively through one of <code>monitor_ptr</code>'s scoped lock classes.
					It is based in part on ideas from
					<ulink url="http://www.research.att.com/~bs/wrapper.pdf">"Wrapping C++ Member Function Calls"</ulink>
					by Bjarne Stroustroup and <ulink url="http://www.cs.wustl.edu/~schmidt/PDF/monitor.pdf">"Monitor Object:
					An Object Behavioral Pattern for Concurrent Programming"</ulink> by Douglas C. Schmidt.
				</para>
				<para>
					Although any object may be passed to a <code>monitor_ptr</code>, special support is provided
					for classes derived from <classname>monitor_base</classname>.  This allows classes derived from
					<classname>monitor_base</classname> to wait on conditions inside member function calls,
					releasing the <code>monitor_ptr</code>'s mutex until the condition is met.
				</para>
				<para>
					The <classname>try_monitor_ptr</classname> and <classname>timed_monitor_ptr</classname>
					variants additionally allow "try locking" or "timed locking" through the
					<classname>try_monitor_ptr::scoped_try_lock</classname> and
					<classname>timed_monitor_ptr::scoped_timed_lock</classname> classes.
				</para>
				<itemizedlist>
					<title>Example Code</title>
					<listitem>
						<para>
							<link linkend="poet.example.monitor_demo.cpp">monitor_demo.cpp</link>
						</para>
					</listitem>
				</itemizedlist>
			</description>
			<access name="public">
				<typedef name="element_type">
					<type>T</type>
				</typedef>
				<typedef name="mutex_type">
					<type>Mutex</type>
				</typedef>
				<class name="scoped_lock">
					<inherit access="public">
						<type><classname>boost::noncopyable</classname></type>
					</inherit>
					<purpose>Scoped lock with member access</purpose>
					<description>
						<para>
							<code>scoped_lock</code> models the ScopedLock concept described by the
							Boost Thread libarary, with its associated Mutex type being <classname>monitor_ptr</classname>.
							In addition, <code>scoped_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object owned
							by a <classname>monitor_ptr</classname> (or the related
							<classname>try_monitor_ptr</classname> or <classname>timed_monitor_ptr</classname>).
						</para>
					</description>
					<access name="public">
						<method-group name="public member functions">
							<method name="lock">
								<type>void</type>
								<description>
									<para>Blocks until it can lock its associated <classname>monitor_ptr</classname>.
									</para>
								</description>
								<postconditions>
									<para><code>locked() == true</code></para>
								</postconditions>
							</method>
							<method name="locked" cv="const">
								<type>bool</type>
								<returns>
									<para><code>true</code> if the <code>scoped_lock</code> has locked its
										associated <classname>monitor_ptr</classname>, <code>false</code> otherwise.
									</para>
								</returns>
							</method>
							<method name="operator-&gt;" cv="const">
								<type>T*</type>
								<description>
									<para>Provides access to the members of the object owned by the <code>scoped_lock</code>'s associated
										<classname>monitor_ptr</classname>.
									</para>
								</description>
								<throws><para><classname>boost::lock_error</classname> if <code>locked() != true</code></para>
								</throws>
							</method>
							<method name="operator*" cv="const">
								<type>T&amp;</type>
								<description>
									<para>Provides access to the object owned by the <code>scoped_lock</code>'s associated
										<classname>monitor_ptr</classname>.
									</para>
								</description>
								<throws><para><classname>boost::lock_error</classname> if <code>locked() != true</code></para>
								</throws>
							</method>
							<method name="unlock">
								<type>void</type>
								<description>
									<para>Releases lock on its associated <classname>monitor_ptr</classname>.
									</para>
								</description>
								<postconditions>
									<para><code>locked() == false</code></para>
								</postconditions>
							</method>
						</method-group>
						<constructor>
							<parameter name="monitor_pointer">
								<paramtype><classname>monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>monitor_ptr</code>, and calls
									<methodname>lock</methodname>.
								</para>
							</description>
							<postconditions>
								<para><code>locked() == true</code></para>
							</postconditions>
						</constructor>
						<constructor>
							<parameter name="monitor_pointer">
								<paramtype><classname>monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>monitor_ptr</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname>lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<class name="call_proxy">
					<purpose>Helper class for <methodname>monitor_ptr::operator-&gt;</methodname>.</purpose>
					<description>
						<para>
							Objects of this class exist as temporary objects resulting from
							<methodname>monitor_ptr::operator-&gt;</methodname> member access calls.
							They forward member access calls to the <classname>monitor_ptr</classname>'s
							underlying pointer, and unlock the <classname>monitor_ptr</classname>'s
							mutex in their destructor.
						</para>
					</description>
					<access name="public">
						<method name="operator->" cv="const">
							<type>const <classname>monitor_ptr::scoped_lock</classname> &amp;</type>
						</method>
					</access>
				</class>
				<method-group name="public member functions">
					<method name="operator->" cv="const">
						<type><classname>call_proxy</classname></type>
						<description>
							<para>Locks the <code>monitor_ptr</code>'s mutex and returns a <classname>call_proxy</classname> object.
								The <code>operator-&gt;()</code> of the returned <classname>call_proxy</classname> object will be
								automatically called in turn (overloading <code>operator-&gt;()</code> is special in that way), which will
								utimately result in a call of <code>operator-&gt;()</code> on the
								<code>monitor_ptr</code>'s underlying pointer.
								The mutex is automatically unlocked after the member access completes by the <classname>call_proxy</classname>
								destructor.
							</para>
							<para>
								If more flexibility is desired, the <classname>monitor_ptr::scoped_lock</classname> class
								provides an alternative to <code>monitor_ptr::operator-&gt;</code>.
							</para>
						</description>
					</method>
					<method name="operator=">
						<type>monitor_ptr&lt;T, Mutex&gt; &amp;</type>
						<parameter name="rhs">
							<paramtype>const monitor_ptr&lt;T, Mutex&gt; &amp;</paramtype>
						</parameter>
						<description>
							<para>After assignment, the two <code>monitor_ptr</code>s will share the same pointer,
								mutex, and condition variable.
							</para>
						</description>
					</method>
					<method name="direct" cv="const">
						<type>const boost::shared_ptr&lt;T&gt; &amp;</type>
						<description><para>Gives direct unlocked access to the underlying pointer.</para></description>
					</method>
				</method-group>
				<constructor>
					<description>
						<para>The default constructor creates a null <code>monitor_ptr</code>.
						</para>
					</description>
				</constructor>
				<constructor specifiers="explicit">
					<parameter name="pointer">
						<paramtype>T*</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>monitor_ptr</code> which wraps the specified pointer.  The <code>monitor_ptr</code>
							internally stores <code>pointer</code> in a <classname>boost::shared_ptr</classname>.
							Thus the pointer will be automatically
							deleted when the last copy of this <code>monitor_ptr</code> is destroyed.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="smart_pointer">
						<paramtype>boost::shared_ptr&lt;T&gt;</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>monitor_ptr</code> which wraps the specified pointer.
							This constructor allows the <code>monitor_ptr</code> to be initialized with
							a <classname>boost::shared_ptr</classname> that has a custom deleter.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="other">
						<paramtype>const monitor_ptr &amp;</paramtype>
					</parameter>
					<description>
						<para>The copy constructor creates a <code>monitor_ptr</code> which shares the same pointer,
							mutex, and condition as the original.
						</para>
					</description>
				</constructor>
				<destructor specifiers="virtual">
					<description>
						<para>A <code>monitor_ptr</code> and all its copies share ownership of an underlying pointer,
							mutex, and condition variable.  The pointer, mutex, and condition are
							deleted when the last copy of the
							<code>monitor_ptr</code> is destroyed.  The deleter for the underlying pointer may
							be customized by using the constructor which takes a <classname>boost::shared_ptr</classname>
							as its parameter.
						</para>
					</description>
				</destructor>
			</access>
		</class>
		<class name="try_monitor_ptr">
			<template>
				<template-type-parameter name="T"/>
				<template-type-parameter name="Mutex">
					<default>boost::try_mutex</default>
				</template-type-parameter>
			</template>
			<inherit access="public">
				<type><classname>monitor_ptr</classname>&lt;T, Mutex&gt;</type>
			</inherit>
			<purpose>Extends monitor_ptr by additionally providing a scoped try lock.</purpose>
			<description>
				<para>
					A <code>try_monitor_ptr</code> is the same as a <classname>monitor_ptr</classname>
					except its default Mutex template type is <classname>boost::try_mutex</classname>,
					and it adds another scoped lock class: <classname>try_monitor_ptr::scoped_try_lock</classname>.
				</para>
			</description>
			<access name="public">
				<class name="scoped_try_lock">
					<inherit access="public">
						<type><classname>monitor_ptr&lt;T, Mutex&gt;::scoped_lock</classname></type>
					</inherit>
					<purpose>Scoped try lock with member access</purpose>
					<description>
						<para>
							<code>scoped_try_lock</code> models the ScopedTryLock concept described by the
							Boost Thread libarary, with its associated Mutex type being <classname>try_monitor_ptr</classname>.
							In addition, <code>scoped_try_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object owned
							by a <classname>try_monitor_ptr</classname> (or the related <classname>timed_monitor_ptr</classname>).
						</para>
					</description>
					<access name="public">
						<method-group name="public member functions">
							<method name="try_lock">
								<type>bool</type>
								<description>
									<para>Makes a non-blocking attempt to lock its associated <classname>try_monitor_ptr</classname>.
									</para>
								</description>
								<returns><para><code>true</code> if a lock was acquired, <code>false</code> otherwise.</para>
								</returns>
							</method>
						</method-group>
						<constructor>
							<parameter name="monitor_pointer">
								<paramtype><classname>try_monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>try_monitor_ptr</code>,
									and calls <methodname>try_lock</methodname>().
								</para>
							</description>
						</constructor>
						<constructor>
							<parameter name="monitor_pointer">
								<paramtype><classname>try_monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>try_monitor_ptr</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname>lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<constructor>
					<description>
						<para>The default constructor creates a null <code>try_monitor_ptr</code>.
						</para>
					</description>
				</constructor>
				<constructor specifiers="explicit">
					<parameter name="pointer">
						<paramtype>T*</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>try_monitor_ptr</code> which wraps the specified pointer.  The <code>try_monitor_ptr</code>
							internally stores <code>pointer</code> in a <classname>boost::shared_ptr</classname>.
							Thus the pointer will be automatically
							deleted when the last copy of this <code>try_monitor_ptr</code> is destroyed.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="smart_pointer">
						<paramtype>boost::shared_ptr&lt;T&gt;</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>try_monitor_ptr</code> which wraps the specified pointer.
							This constructor allows the <code>try_monitor_ptr</code> to be initialized with
							a <classname>boost::shared_ptr</classname> that has a custom deleter.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="other">
						<paramtype>const try_monitor_ptr &amp;</paramtype>
					</parameter>
					<description>
						<para>The copy constructor creates a <code>try_monitor_ptr</code> which shares the same pointer,
							mutex, and condition as the original.
						</para>
					</description>
				</constructor>
			</access>
		</class>
		<class name="timed_monitor_ptr">
			<template>
				<template-type-parameter name="T"/>
				<template-type-parameter name="Mutex">
					<default>boost::timed_mutex</default>
				</template-type-parameter>
			</template>
			<inherit access="public">
				<type><classname>try_monitor_ptr</classname>&lt;T, Mutex&gt;</type>
			</inherit>
			<purpose>Extends try_monitor_ptr by additionally providing a scoped timed lock.</purpose>
			<description>
				<para>
					A <code>timed_monitor_ptr</code> is the same as a <classname>try_monitor_ptr</classname>
					except its default Mutex template type is <classname>boost::timed_mutex</classname>,
					and it adds another scoped lock class: <classname>timed_monitor_ptr::scoped_timed_lock</classname>.
				</para>
			</description>
			<access name="public">
				<class name="scoped_timed_lock">
					<inherit access="public">
						<type><classname>try_monitor_ptr&lt;T, Mutex&gt;::scoped_try_lock</classname></type>
					</inherit>
					<purpose>Scoped timed lock with member access</purpose>
					<description>
						<para>
							<code>scoped_timed_lock</code> models the ScopedTimedLock concept described by the
							Boost Thread libarary, with its associated Mutex type being <classname>timed_monitor_ptr</classname>.
							In addition, <code>scoped_timed_lock</code> can be used like a pointer via its
							member access and dereference operators, which provide safe access to an object owned
							by a <classname>timed_monitor_ptr</classname>.
						</para>
					</description>
					<access name="public">
						<method-group name="public member functions">
							<method name="timed_lock">
								<template>
									<template-type-parameter name="Timeout">
									</template-type-parameter>
								</template>
								<type>bool</type>
								<parameter name="timeout">
									<paramtype>const Timeout &amp;</paramtype>
								</parameter>
								<description>
									<para>Blocks for up to the time specified by the <code>timeout</code> parameter (which is passed to the
										<code>timed_lock</code> method of the underlying <code>Mutex::scoped_timed_lock</code> object) in an
										attempt to lock its associated <classname>timed_monitor_ptr</classname>.
									</para>
								</description>
								<returns><para><code>true</code> if a lock was acquired, <code>false</code> otherwise.</para>
								</returns>
							</method>
						</method-group>
						<constructor>
							<template>
								<template-type-parameter name="Timeout">
								</template-type-parameter>
							</template>
							<parameter name="monitor_pointer">
								<paramtype><classname>timed_monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="timeout">
								<paramtype>const Timeout &amp;</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>timed_monitor_ptr</code>,
									and calls <code><methodname>timed_lock</methodname>(timeout)</code>.
								</para>
							</description>
						</constructor>
						<constructor>
							<parameter name="monitor_pointer">
								<paramtype><classname>timed_monitor_ptr</classname>&lt;T, Mutex&gt; &amp;</paramtype>
							</parameter>
							<parameter name="do_lock">
								<paramtype>bool</paramtype>
							</parameter>
							<description>
								<para>Creates a scoped lock which can be used to safely
									access the object owned by a <code>timed_monitor_ptr</code>.
									If <code>do_lock</code> is <code>true</code>, calls
									<methodname>lock</methodname>().
								</para>
							</description>
							<postconditions>
								<para><code>locked() == do_lock</code></para>
							</postconditions>
						</constructor>
					</access>
				</class>
				<constructor>
					<description>
						<para>The default constructor creates a null <code>timed_monitor_ptr</code>.
						</para>
					</description>
				</constructor>
				<constructor specifiers="explicit">
					<parameter name="pointer">
						<paramtype>T*</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>timed_monitor_ptr</code> which wraps the specified pointer.  The <code>timed_monitor_ptr</code>
							internally stores <code>pointer</code> in a <classname>boost::shared_ptr</classname>.
							Thus the pointer will be automatically
							deleted when the last copy of this <code>timed_monitor_ptr</code> is destroyed.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="smart_pointer">
						<paramtype>boost::shared_ptr&lt;T&gt;</paramtype>
					</parameter>
					<description>
						<para>Creates a <code>timed_monitor_ptr</code> which wraps the specified pointer.
							This constructor allows the <code>timed_monitor_ptr</code> to be initialized with
							a <classname>boost::shared_ptr</classname> that has a custom deleter.
						</para>
					</description>
				</constructor>
				<constructor>
					<parameter name="other">
						<paramtype>const timed_monitor_ptr &amp;</paramtype>
					</parameter>
					<description>
						<para>The copy constructor creates a <code>timed_monitor_ptr</code> which shares the same pointer,
							mutex, and condition as the original.
						</para>
					</description>
				</constructor>
			</access>
		</class>
	</namespace>
</header>
