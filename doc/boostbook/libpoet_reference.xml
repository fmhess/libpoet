<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<boostbook>
<library dirname="mydir" name="libpoet" id="libpoet">
<library-reference>
	<header name="poet/active_object.hpp">
		<namespace name="poet">
			<class name="method_request_base" id="method_request_base_id">
				<purpose>Base class for method requests. </purpose>
				<typedef name="update_slot_type">
					<description><para>Slot type used by connectUpdate(). </para></description>
					<type>boost::signal&lt; void()&gt;::slot_type</type>
				</typedef>
				<method-group name="public member functions">
					<method name="run" cv="">
						<type>void</type>
						<description><para>run() is called by schedulers to execute the method request. </para></description>
					</method>
					<method name="ready" cv="const">
						<type>bool</type>
						<description><para>Schedulers will not execute the method request until ready() returns true. The default implementation always returns true. </para></description>
					</method>
					<method name="cancel" cv=""><type>void</type>
						<description><para>If a method request is still waiting in the scheduler's activation queue, cancel() will cause it to be dropped from the queue without being executed. </para></description>
					</method>
					<method name="cancelled" cv="const">
						<type>bool</type>
						<description><para></para></description>
						<returns><para>true if the method request has been cancelled. </para></returns>
					</method>
					<method name="connect_update" cv="">
						<type>boost::signalslib::connection</type>
						<parameter name="slot"><paramtype>const update_slot_type &amp;</paramtype></parameter>
						<description>
							<para>Connect a slot to the method request's "update" signal. The slot will be run whenever the status of the method request changes, for example if it is cancelled, or if its "ready" state changes. </para>
						</description>
					</method>
				</method-group>
				<constructor>
					<description><para>Constructor. </para>
					</description>
				</constructor>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
			</class>
			<class name="method_request">
				<template>
					<template-type-parameter name="ResultType"/>
				</template>
				<inherit access="public">poet::method_request_base</inherit>
				<inherit access="public">boost::postconstructible</inherit>
				<inherit access="public">boost::enable_shared_from_this&lt; T &gt;</inherit>
				<purpose>Method request base class with support for cancellation via return value. </purpose>
				<typedef name="result_type">
					<description><para>ResultType </para></description>
					<type>ResultType</type>
				</typedef>
				<method-group name="public member functions">
					<method name="cancel" cv="">
						<type>void</type>
						<description><para>Calls method_request_base::cancel() and additionally cancels the method_request's return value. </para></description>
					</method>
				</method-group>
				<destructor>
					<description><para>Virtual destructor </para></description>
				</destructor>
				<method-group name="protected member functions">
					<method name="postconstruct" cv="">
						<type>void</type>
						<description>
							<para>Post-constructor. Performs some signal-slot connection with automatic lifetime tracking which cannot be performed in the constructor due to the need for a shared_ptr from this. </para>
						</description>
					</method>
					<method name="handleReturnValueUpdate" cv="">
						<type>void</type>
					</method>
				</method-group>
				<constructor>
					<parameter name="returnValue">
						<paramtype>const <classname>promise</classname>&lt; result_type &gt; &amp;</paramtype>
						<description><para>The future which will be cancelled if this method_request is cancelled. Conversely, cancelling returnValue will also cause this method_request to be cancelled. </para></description>
					</parameter>
					<description><para>Protected constructor. This class uses a post-constructor provided by the deconstruct_ptr() framework, so derived classes should only be instantiated via calls to boost::deconstruct_ptr(). It is recommended that derived classes use protected/private constructors and provide a static factory method which calls boost::deconstruct_ptr().</para></description>
				</constructor>
			</class>
			<class name="activation_queue_base">
				<purpose>Base class for activation queues. </purpose>
				<typedef name="size_type"><type>unsigned long</type></typedef>
				<method-group name="public member functions">
					<method name="push_back" cv="">
						<type>void</type>
						<parameter name="request"><paramtype>const boost::shared_ptr&lt; <classname>method_request_base</classname> &gt; &amp;</paramtype></parameter>
						<description><para>Adds a new method request to the activation queue. </para></description>
					</method>
					<method name="getRequest" cv="">
						<type>boost::shared_ptr&lt; <classname>method_request_base</classname> &gt;</type>
						<description><para></para></description>
						<returns><para>The next method request which is ready to run. Returns a null shared_ptr if there are no method requests ready. </para></returns>
					</method>
					<method name="clear" cv=""><type>void</type><description><para>Empties all method requests from the queue. </para></description>
					</method>
					<method name="size" cv="const">
						<type>size_type</type>
						<description><para></para></description>
						<returns><para>the number of method requests waiting in the queue. </para></returns>
					</method>
					<method name="empty" cv="const">
						<type>bool</type><description><para></para></description>
						<returns><para>true if size() is zero. </para></returns>
					</method>
				</method-group>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
			</class>
			<class name="in_order_activation_queue">
				<inherit access="public">poet::activation_queue_base</inherit>
				<purpose>An activation queue which always keeps method requests in FIFO order. </purpose>
				<description><para>An in_order_activation_queue will never skip over method requests that aren't ready yet. If you don't require the method requests to be executed in the exact order they were received, use an out_of_order_activation_queue instead. </para></description>
				<method-group name="public member functions">
					<method name="push_back" cv="">
						<type>void</type>
						<parameter name="request"><paramtype>const boost::shared_ptr&lt; <classname>method_request_base</classname> &gt; &amp;</paramtype></parameter>
						<description><para>Adds a new method request to the activation queue. </para></description>
					</method>
					<method name="getRequest" cv="">
						<type>boost::shared_ptr&lt; <classname>method_request_base</classname> &gt;</type>
						<description><para></para></description>
						<returns><para>The oldest method request in the queue. If the oldest method request is not ready to execute, then a null shared_ptr is returned. </para></returns>
					</method>
					<method name="clear" cv="">
						<type>void</type>
						<description><para>Empties all method requests from the queue. </para></description>
					</method>
					<method name="size" cv="const">
						<type>size_type</type>
						<description><para></para></description>
						<returns><para>the number of method requests waiting in the queue. </para></returns>
					</method>
					<method name="empty" cv="const">
						<type>bool</type>
						<description><para></para></description>
						<returns><para>true if size() is zero. </para></returns>
					</method>
				</method-group>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
				<method-group name="protected member functions">
					<method name="unlockedGetRequest" cv="">
						<type>boost::shared_ptr&lt; <classname>method_request_base</classname> &gt;</type>
					</method>
				</method-group>
			</class>
			<class name="out_of_order_activation_queue">
				<inherit access="public">poet::in_order_activation_queue</inherit>
				<purpose>An activation queue which can reorder method requests. </purpose>
				<description><para>An out_of_order_activation_queue will return the oldest method request which is currently ready for execution. Thus, a single method request which is not ready will never prevent other method requests which are ready from running. </para></description>
				<method-group name="public member functions">
					<method name="getRequest" cv="">
						<type>boost::shared_ptr&lt; <classname>method_request_base</classname> &gt;</type>
						<description><para></para></description>
						<returns><para>The oldest method request in the queue which is currently ready for execution. </para></returns>
					</method>
				</method-group>
				<destructor/>
			</class>
			<class name="scheduler_base">
				<purpose>Base class for schedulers. </purpose>
				<description><para>A scheduler creates its own thread and executes method requests which are passed to it through its activation queue. </para></description>
				<method-group name="public member functions">
					<method name="post_method_request" cv="">
						<type>void</type>
						<parameter name="methodRequest"><paramtype>const boost::shared_ptr&lt; <classname>method_request_base</classname> &gt; &amp;</paramtype></parameter>
						<description><para>Adds methodRequest to the scheduler's activation queue. </para></description>
					</method>
					<method name="wake" cv="">
						<type>void</type>
						<description><para>Manually force the scheduler to wake up and check for runnable method requests. This is usually not required, as schedulers should automatically check there activation queue when post_method_request is called, or when any method request in the activation queue emits its "update" signal. </para></description>
					</method>
					<method name="kill" cv="">
						<type>void</type>
						<description><para>Tells scheduler thread to exit. The scheduler thread may still be running after this function returns. </para></description>
					</method>
					<method name="join" cv=""><type>void</type><description><para>Blocks until the scheduler thread exits. </para></description></method>
				</method-group>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
			</class>
			<class name="scheduler"><inherit access="public">poet::scheduler_base</inherit>
				<purpose>Execute method requests in a separate thread. </purpose>
				<method-group name="public member functions">
					<method name="post_method_request" cv="">
						<type>void</type>
						<parameter name="methodRequest"><paramtype>const boost::shared_ptr&lt; <classname>method_request_base</classname> &gt; &amp;</paramtype></parameter>
						<description><para>Adds methodRequest to the scheduler's activation queue. </para></description>
					</method>
					<method name="wake" cv="">
						<type>void</type><description><para>Manually force the scheduler to wake up and check for runnable method requests. This is usually not required, as schedulers should automatically check there activation queue when post_method_request is called, or when any method request in the activation queue emits its "update" signal. </para></description>
					</method>
					<method name="kill" cv="">
						<type>void</type>
						<description><para>Tells scheduler thread to exit. The scheduler thread may still be running after this function returns. </para></description>
					</method>
					<method name="join" cv="">
						<type>void</type>
						<description><para>Blocks until the scheduler thread exits.</para></description>
					</method>
				</method-group>
				<constructor>
					<parameter name="millisecTimeout"><paramtype>int</paramtype><default>-1</default>
						<description><para>Specifies a polling interval for the scheduler to check for any ready method requests in its activation queue. If millisecTimeout is less than zero, no polling is performed. Polling is usually not required, as schedulers will always check there activation queue when post_method_request is called, or when any method request in the activation queue emits its "update" signal. </para></description>
					</parameter>
					<parameter name="activationQueue">
						<paramtype>const boost::shared_ptr&lt; <classname>activation_queue_base</classname> &gt; &amp;</paramtype>
						<default>boost::shared_ptr&lt; activation_queue_base &gt;(new out_of_order_activation_queue)</default>
						<description><para>Allows use of a customized activation queue. By default, an out_of_order_activation_queue is used. </para></description>
					</parameter>
					<description>
						<para>The scheduler constructer will create a new thread of execution, where the scheduler will execute method requests.</para>
					</description>
				</constructor>
				<destructor>
					<description><para>The scheduler thread will continue to run after the scheduler object is destroyed, until all method requests in its activation queue have been dispatched. </para></description>
				</destructor>
			</class>
		</namespace>
	</header>
	<header name="/home/fhess/cvs/libpoet/doc/doxygen_bogus.h">
		<namespace name="boost">
			<class name="enable_shared_from_this">
				<template><template-type-parameter name="T"/></template>
				<purpose>boost::enable_shared_from_this </purpose>
				<description><para>See boost documentation for more information. </para></description>
			</class>
			<class name="slot">
				<template>
					<template-type-parameter name="Signature"/>
					<template-type-parameter name="SlotFunction"><default>boost::function&lt;Signature&gt;</default></template-type-parameter>
				</template>
				<purpose>boost::slot </purpose>
				<description><para>See the documentation for the slot class in thread_safe_signals for more information. </para></description>
			</class>
			<class name="postconstructible">
				<purpose>boost::postconstructible </purpose>
				<description><para>See the documentation for postconstructible in thread_safe_signals for more information. </para></description>
			</class>
		</namespace>
		<namespace name="poet">
			<class name="active_function">
				<template><template-type-parameter name="Signature"/></template>
				<purpose>Create an active object from an ordinary function or object. </purpose>
				<description><para>In the following, the active_function is taken to have a signature of: <programlisting>active_function&lt;R (T1, T2, ..., TN)&gt;</programlisting></para></description>
				<typedef name="passive_result_type">
					<description><para>R </para></description>
					<type>boost::function_traits&lt; Signature &gt;::<classname>result_type</classname></type>
				</typedef>
				<typedef name="result_type">
					<description><para>future&lt;R&gt; </para></description>
					<type><classname>poet::future</classname>&lt; <classname>passive_result_type</classname> &gt;</type>
				</typedef>
				<typedef name="passive_slot_type">
					<description><para>Slot type for the passive function the active_function is constructed from. </para></description>
					<type><classname>boost::slot</classname>&lt; Signature &gt;</type>
				</typedef>
				<method-group name="public member functions">
					<method name="operator()" cv="const"><type><classname>future</classname>&lt; R &gt;</type>
						<parameter name="arg1"><paramtype><classname>future</classname>&lt; T1 &gt;</paramtype></parameter>
						<parameter name="arg2"><paramtype><classname>future</classname>&lt; T2 &gt;</paramtype></parameter>
						<parameter name=""><paramtype>...</paramtype></parameter>
						<parameter name="argN"><paramtype><classname>future</classname>&lt; TN &gt;</paramtype></parameter>
						<description><para>Const overload. </para></description>
					</method>
					<method name="operator()" cv=""><type><classname>future</classname>&lt; R &gt;</type>
						<parameter name="arg1"><paramtype><classname>future</classname>&lt; T1 &gt;</paramtype></parameter>
						<parameter name="arg2"><paramtype><classname>future</classname>&lt; T2 &gt;</paramtype></parameter>
						<parameter name=""><paramtype>...</paramtype></parameter>
						<parameter name="argN"><paramtype><classname>future</classname>&lt; TN &gt;</paramtype></parameter>
						<description>
							<para>Invocation creates a method request and sends it to the active_function's scheduler. The method request may be cancelled by calling future::cancel() on the returned future.</para>
							<para>Note the active_function takes futures as arguments, as well as returning a future. This allows future results to be passed from one active_function to another without waiting for the result to become ready. Since futures are constructible from their value types, the active_function can also take ordinary values not wrapped futures as arguments. </para>
						</description>
					</method>
					<method name="wake" cv="">
						<type>void</type>
						<description><para>Calls scheduler_base::wake() on the active_function's scheduler. </para></description>
					</method>
					<method name="expired" cv="const">
						<type>bool</type>
						<description><para>Calls the boost::slot::expired() query method on the slot this active_function was constructed from. </para></description>
					</method>
				</method-group>
				<constructor>
					<parameter name="passive_function">
						<paramtype>const <classname>passive_slot_type</classname> &amp;</paramtype>
						<description><para>The underlying function this active_function object will call. The boost::slot class supports tracking of arbitrary boost::shared_ptr which are associated with the slot. For example, if the slot is constructed from a non-static member function, the lifetime of the member function's object can be tracked and the slot prevented from running after the object is destroyed. </para></description>
					</parameter>
					<parameter name="guard">
						<paramtype>const boost::function&lt; bool()&gt; &amp;</paramtype>
						<default>0</default>
						<description><para>The active_function's scheduler will not execute a method request until the guard returns true and all the input futures are ready. By default, the guard will always return true. </para></description>
					</parameter>
					<parameter name="scheduler_ptr">
						<paramtype>boost::shared_ptr&lt; <classname>scheduler_base</classname> &gt;</paramtype>
						<default>boost::shared_ptr&lt; scheduler_base &gt;()</default>
						<description><para>Specify a scheduler object for the active_function to post its method requests to. By default, a new Scheduler object is created for the active_function. If the active_function is providing a method as part of an active object class, you may wish for all the class' methods to share the same scheduler. </para></description>
					</parameter>
					<description><para></para></description>
				</constructor>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
			</class>
		</namespace>
	</header>
	<header name="/home/fhess/cvs/libpoet/doc/doxygen_future_void.h">
		<namespace name="poet">
			<class-specialization name="future">
				<template></template>
				<specialization>
					<template-arg>void</template-arg>
				</specialization>
				<purpose>A void specialization of the future template class. </purpose>
				<description><para>future&lt;void&gt; is for futures with no value. For example, it may be used to wait on the completion of an asynchronous function which has no return value. In addition, a future&lt;void&gt; can assigned or constructed from a future&lt;T&gt; where T is any type. This allows a future&lt;void&gt; to be used by code which is only interested in whether the future is ready or has an exception, and is not interested in the future's specific value or template type. </para></description>
				<typedef name="value_type">
					<description><para>void </para></description>
					<type>void</type>
				</typedef>
				<typedef name="update_slot_type">
					<description><para>boost::signal&lt;void ()&gt;slot_type </para></description>
					<type>boost::signal&lt; void()&gt;::slot_type</type>
				</typedef>
				<method-group name="public member functions">
					<method name="future" cv=""><type/>
						<parameter name="promise_in"><paramtype>const <classname>promise</classname>&lt; void &gt; &amp;</paramtype></parameter>
						<description><para>Same as the corresponding constructor for an unspecialized future&lt;T&gt;. </para></description>
					</method>
					<method name="future" cv="">
						<type/>
						<template>
							<template-type-parameter name="OtherType"/>
						</template>
						<parameter name="promise"><paramtype>const <classname>promise</classname>&lt; OtherType &gt; &amp;</paramtype></parameter>
						<description><para>A future&lt;void&gt; can be constructed from any type of promise. </para></description>
					</method>
					<method name="future" cv=""><type/>
						<template><template-type-parameter name="OtherType"/></template>
						<parameter name="other"><paramtype>const <classname>future</classname>&lt; OtherType &gt; &amp;</paramtype></parameter>
						<description><para>A future&lt;void&gt; can be constructed from any type of future. </para></description>
					</method>
					<method name="future" cv=""><type/>
						<description><para>Same as the corresponding function for an unspecialized future&lt;T&gt;. </para></description>
					</method>
					<method name="~future" cv="">
						<type>virtual</type><description><para>Virtual destructor. </para></description>
					</method>
					<method name="get" cv="const">
						<type>void</type>
						<description><para>A future&lt;void&gt; has no value, but get() can still be used to block until the future's promise is fulfilled or reneged.</para></description>
						<throws><simpara><classname>unspecified</classname> </simpara></throws>
					</method>
					<method name="conversion-operator" cv="const">
						<type>void</type>
						<description><para>The conversion operator has the same effects as the explicit get() function. </para></description>
					</method>
					<method name="timed_join" cv="const">
						<type>bool</type>
						<parameter name="absolute_time"><paramtype>const boost::xtime &amp;</paramtype></parameter>
						<description><para>Same as the corresponding function for an unspecialized future&lt;T&gt;. </para></description>
					</method>
					<method name="ready" cv="const">
						<type>bool</type>
						<description><para>Same as the corresponding function for an unspecialized future&lt;T&gt;. </para></description></method>
					<method name="connect_update" cv="const">
						<type>boost::signalslib::connection</type>
						<parameter name="slot"><paramtype>const update_slot_type &amp;</paramtype></parameter>
						<description><para>Same as the corresponding function for an unspecialized future&lt;T&gt;. </para></description>
					</method>
					<method name="cancel" cv="">
						<type>void</type>
						<description><para>Same as the corresponding function for an unspecialized future&lt;T&gt;. </para></description>
					</method>
					<method name="has_exception" cv="const">
						<type>bool</type>
						<description><para>Same as the corresponding function for an unspecialized future&lt;T&gt;. </para></description>
					</method>
				</method-group>
				<copy-assignment>
					<template>
						<template-type-parameter name="OtherType"/>
					</template>
					<parameter name="other"><paramtype>const <classname>future</classname>&lt; OtherType &gt; &amp;</paramtype>
					</parameter>
					<description><para>A future&lt;void&gt; can be assigned any type of future. </para></description>
				</copy-assignment>
			</class-specialization>
			<class-specialization name="promise">
				<template></template>
				<specialization>
					<template-arg>void</template-arg>
				</specialization>
				<purpose>A void specialization of the promise template class. </purpose>
				<description><para>promise&lt;void&gt; may be used to create future&lt;void&gt; objects which have no value. In addition, a promise&lt;void&gt; can be constructed from a promise&lt;T&gt; where T is any type. This allows a promise&lt;void&gt; to be used by code which only needs to be able to renege on a promise and not fulfill it. </para></description>
				<typedef name="value_type">
					<description><para>void </para></description>
					<type>void</type></typedef>
				<method-group name="public member functions">
					<method name="promise" cv="">
						<type/>
						<description><para>Same as the corresponding constructor for an unspecialized promise&lt;T&gt;. </para></description>
					</method>
					<method name="promise" cv="">
						<type/>
						<parameter name="other"><paramtype>const <classname>promise</classname>&lt; void &gt; &amp;</paramtype></parameter>
						<description><para>Same as the corresponding constructor for an unspecialized promise&lt;T&gt;. </para></description>
					</method>
					<method name="promise" cv=""><type/>
						<template><template-type-parameter name="OtherType"/></template>
						<parameter name="other">
							<paramtype>const <classname>promise</classname>&lt; OtherType &gt; &amp;</paramtype></parameter>
						<description><para>A promise&lt;void&gt; may be constructed from a promise with any template type, although it cannot fulfill() such a promise. It can renege on the promise, however. </para></description>
					</method>
					<method name="fulfill" cv="">
						<type>void</type>
						<parameter name="future_value"><paramtype>const <classname>future</classname>&lt; void &gt; &amp;</paramtype></parameter>
						<description><para>Same as the corresponding function for an unspecialized promise&lt;T&gt;. </para></description>
					</method>
					<method name="fulfill" cv="">
						<type>void</type>
						<description><para>Will make any future&lt;void&gt; objects referencing this promise become ready.</para></description>
						<throws><simpara><classname>std::invalid_argument</classname> </simpara></throws></method><method name="renege" cv="">
						<type>void</type>
						<template><template-type-parameter name="E"/></template>
						<parameter name="exception"><paramtype>const E &amp;</paramtype></parameter>
						<description><para>Same as the corresponding function for an unspecialized promise&lt;T&gt;. </para></description>
					</method>
					<method name="renege" cv="">
						<type>void</type><parameter name="exp"><paramtype>const poet::exception_ptr &amp;</paramtype></parameter>
						<description><para>Same as the corresponding function for an unspecialized promise&lt;T&gt;. </para></description>
					</method>
				</method-group>
			</class-specialization>
		</namespace>
	</header>
	<header name="/home/fhess/cvs/libpoet/poet/exception_ptr.hpp">
		<namespace name="poet"/>
	</header>
	<header name="/home/fhess/cvs/libpoet/poet/exceptions.hpp">
		<namespace name="poet">
			<class name="cancelled_future">
				<inherit access="public">std::runtime_error</inherit>
				<purpose>Exception thrown by a cancelled future. </purpose>
				<description><para>This exception is thrown when an attempt to convert a future to its associated value fails due to future::cancel() being called on a future that references the same promise. </para></description>
				<method-group name="public member functions"/>
				<constructor>
					<description><para>Constructor. </para></description>
				</constructor>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
			</class>
			<class name="uncertain_future">
				<inherit access="public">std::runtime_error</inherit>
				<purpose>Exception thrown by an uncertain future.</purpose>
				<description><para>This exception is thrown when an attempt is made to convert a future with no promise into its associated value. This can happen if the future was default-constructed, or its associated promise object has been destroyed without being fulfilled. </para></description>
				<method-group name="public member functions"/>
				<constructor>
					<description><para>Constructor. </para></description>
				</constructor>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
			</class>
			<class name="unknown_exception">
				<inherit access="public">std::runtime_error</inherit>
				<purpose>Exception used as a placeholder for unknown exceptions. </purpose>
				<description><para>Exceptions unknown by the current_exception() code are replaced with this class. It is also used to replace exceptions whose exact type is unknown but which are derived from std::exception, in which case the what() string will be made to match the what() string of the original unknown exception. </para></description>
				<method-group name="public member functions"/>
				<constructor><parameter name="description"><paramtype>const std::string &amp;</paramtype><default>"poet::unknown_exception"</default></parameter>
				</constructor>
				<destructor/>
			</class>
		</namespace>
	</header>
	<header name="/home/fhess/cvs/libpoet/poet/future.hpp">
		<namespace name="poet">
			<class name="promise">
				<template><template-type-parameter name="T"/></template>
				<purpose>A handle to a promise. </purpose>
				<description>
					<para>Promises are used to construct futures and set their values when they become available. You can also renege on a promise, which transports an exception instead of a value to any futures waiting on the promise.</para>
					<para>Promise objects are handles with shallow copy semantics. Promises are reference-counted, which means a promise will automatically be reneged with an uncertain_future exception if its reference count drops to zero without the promise being fulfilled.</para>
					<para>The idea of making a seperate promise class from the future class was suggested by Chirtopher Kohlhoff. The idea of reference counting the promise class was due to Braddock Gaskill. </para>
				</description>
				<typedef name="value_type">
					<type>T</type>
				</typedef>
				<method-group name="public member functions">
					<method name="fulfill" cv="">
						<type>void</type>
						<parameter name="value"><paramtype>const T &amp;</paramtype></parameter>
						<description><para>Fulfill the promise by giving it a value. All futures which reference this promise will become ready. </para></description>
					</method>
					<method name="fulfill" cv="">
						<type>void</type>
						<parameter name="future_value"><paramtype>const <classname>future</classname>&lt; T &gt; &amp;</paramtype></parameter>
						<description><para>Chain the promise to another promise by giving it a future. All futures which reference this promise will receive the value from future_value when it becomes ready. If the promise referenced by future_value is broken, this promise will also be broken. </para></description>
					</method>
					<method name="renege" cv="">
						<type>void</type>
						<template><template-type-parameter name="E"/></template>
						<parameter name="exception"><paramtype>const E &amp;</paramtype></parameter>
						<description><para>Breaks the promise. Any futures which reference the promise will throw a copy of exception when they attempt to get their value. </para></description>
					</method>
					<method name="renege" cv="">
						<type>void</type>
						<parameter name="exp"><paramtype>const poet::exception_ptr &amp;</paramtype></parameter>
					</method></method-group><constructor/></class><class name="future">
				<template><template-type-parameter name="T"/></template>
				<purpose>A handle to a future value. </purpose>
				<description>
					<para>Futures are wrappers around values which may not exist yet. They are used to support asyncronous function calls. Since a Future can be returned before any result is actually ready, an asyncronous call can return a Future immediately without blocking the calling thread. The calling thread can then poll the future to determine when a result is ready, or block on the Future waiting for a result.</para>
					<para>Futures are handles with shallow copy semantics. Two copies of a future will both refer to the same promise. </para>
				</description>
				<typedef name="value_type">
					<description><para>T </para></description>
					<type>T</type>
				</typedef>
				<typedef name="update_slot_type">
					<description><para>boost::signal&lt;void ()&gt;slot_type </para></description>
					<type><emphasis>unspecified</emphasis></type>
				</typedef>
				<method-group name="public member functions">
					<method name="ready" cv="const"><type>bool</type>
						<description><para></para></description>
						<returns><para>true if the future's value is initialized. </para></returns>
					</method>
					<method name="get" cv="const">
						<type>const T &amp;</type>
						<description><para>get() is used to obtain an initialized value from a future. If the future is not ready, then get() will block until the future's value is initialized, or the future's promise is broken. The future's value may also be obtained without an explicit call to get(), through the conversion operator.</para></description>
						<returns><para>the future's value. </para></returns>
						<throws><simpara><classname>unspecified</classname> </simpara></throws>
					</method>
					<method name="conversion-operator" cv="const">
						<type>const T &amp;</type>
						<description><para>The conversion operator provides implicit conversions to values. It has the same effects as the explicit get() function. </para></description>
					</method>
					<method name="timed_join" cv="const">
						<type>bool</type>
						<parameter name="absolute_time"><paramtype>const boost::xtime &amp;</paramtype></parameter>
						<description><para>timed_join() blocks until <computeroutput>absolute_time</computeroutput> is reached, or either ready() or has_exception() becomes true.</para></description>
						<returns><para>true if either ready() or has_exception() are true. </para></returns>
					</method>
					<method name="connect_update" cv="const">
						<type>boost::signalslib::connection</type>
						<parameter name="slot"><paramtype>const update_slot_type &amp;</paramtype></parameter>
						<description><para>Connect a slot to be run when the future's status changes, either because its value is ready or its promise has been broken. </para></description>
					</method>
					<method name="cancel" cv="">
						<type>void</type>
						<description><para>Cancel a future by reneging on its promise with a cancelled_future exception. </para></description>
					</method>
					<method name="has_exception" cv="const">
						<type>bool</type>
						<description><para></para></description>
						<returns><para>true if this future's promise has been broken. Attempting to get the future's value will throw an exception that may give more information on why the promise was broken. </para></returns>
					</method>
				</method-group>
				<constructor>
					<parameter name="promise"><paramtype>const <classname>promise</classname>&lt; T &gt; &amp;</paramtype></parameter>
					<description><para>Creates a new future from a promise. When the promise referenced by promise is fulfilled, the future will become ready. </para></description>
				</constructor>
				<constructor><template><template-type-parameter name="OtherType"/></template>
					<parameter name="promise"><paramtype>const <classname>promise</classname>&lt; OtherType &gt; &amp;</paramtype></parameter>
					<description><para>Creates a new future from a promise with a template type OtherType that is implicitly convertible to the future's value_type. When the promise referenced by promise is fulfilled, the future will become ready. </para></description>
				</constructor>
				<constructor><parameter name="value"><paramtype>const T &amp;</paramtype></parameter>
					<description><para>Creates a new Future with an initialized value, and provides implicit conversion from a value to the corresponding Future. </para></description>
				</constructor><constructor>
					<template><template-type-parameter name="OtherType"/></template>
					<parameter name="other"><paramtype>const <classname>future</classname>&lt; OtherType &gt; &amp;</paramtype></parameter>
					<description><para>Creates a future from another future with a compatible template type. The two Futures will both reference the same promise. </para></description>
				</constructor>
				<constructor>
					<description><para>Creates an uncertain future with no promise. An attempt to get an uncertain future's value will throw an uncertain_future exception. An uncertain future may gain promise by assigning it another future with promise. </para></description>
				</constructor>
				<destructor>
					<description><para>Virtual destructor. </para></description>
				</destructor>
				<copy-assignment>
					<template><template-type-parameter name="OtherType"/></template>
					<parameter name="other"><paramtype>const <classname>future</classname>&lt; OtherType &gt; &amp;</paramtype></parameter>
					<description><para>Assignment from a future&lt;U&gt; is supported if U is implicitly convertible to T. The assignment happens immediately, and does not block waiting for other to become ready. </para></description>
				</copy-assignment>
			</class>
		</namespace>
	</header>
</library-reference>
</library>
</boostbook>